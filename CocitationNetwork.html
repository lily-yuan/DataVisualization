<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>DAVID M. KRACKHARDT's cocitation network</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <div class="flex-container">
        <div class="flex-item"> Dispelling force between Nodes </div>
        <div class="flex-item"> Force on X_axis </div>
        <div class="flex-item"> Force On Y_axis </div>
    <br><br>
    <select id = "button", class = "flex-item">
        <option value= 1>SHOWING TEXT</option>
        <option value= 2 selected = "selected">HIDING TEXT</option>
    </select>
    </div>
    <div class="container">
        <input type="range" min="-120" max="0" value="-60" class="slider_dispel" id="gravity">
        <input type="range" min="0" max="100" value="10" class="slider_forcex" id="forceX">
        <input type="range" min="0" max="100" value="30" class="slider_forcey" id="forceY">
    </div>


    <style>
        svg {
            max-width: 100%;
            margin: 0.2em;
            padding: 10px;
            font-size: 1vw;
            font-family: sans-serif;
        }
        /* all words shown on the slider. */ 
        .flex-container {
            top: 3em;
            display: flex;
        }
        .flex-item {
            position: relative;
            top: 3em;
            font-size: 1.5em;
            margin-right: 3em;
        }

        /*slider containers.*/
        .container {
            display: flex;
        }

        .slider_dispel {
            position: relative;
            top: 3em;
            right: 20em;
            -webkit-appearance: none;
            width: 10%!important;
            height: 25px!important;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .7s;
            transition: opacity .7s;
            margin-right: 11em;
        }
        .slider_forcex {
            position: relative;
            top: 3em;
            right: 20em;
            -webkit-appearance: none;
            width: 10%!important;
            height: 25px!important;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .01s;
            transition: opacity .01s;
            margin-right: 8em;
        }
        .slider_forcey {
            position: relative;
            top: 3em;
            right: 20em;
            -webkit-appearance: none;
            width: 10%!important;
            height: 25px!important;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .7s;
            transition: opacity .7s;
            margin-right: 2em;
        }

        /* button for showing the text or not. */ 
        #button{
            height: 3em;
            width: 10em;
            color:#01070a;
            font-size: 1.5em;
            direction: rtl;
        }
        .noselect {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .tooltip {
            position: relative;
            display: inline-block;
            border-bottom: 1px dotted black; /* If you want dots under the hoverable text */
            }

            /* Tooltip text */
            .tooltip .tooltiptext {
            visibility: hidden;
            width: 120px;
            background-color: black;
            color: #fff;
            text-align: center;
            padding: 5px 0;
            border-radius: 6px;
            
            /* Position the tooltip text - see examples below! */
            position: absolute;
            z-index: 1;
            }
        #tooltip_id {
            font-size: 10pt;
            font-weight: 900;

            fill: #000000;
        }
        #tooltip_description {
            font-size: 10pt;
            font-weight: 900;

            fill: #000000;
            width: 150px;
            height: 300px;
        }
        #tooltip_nums {
            font-size: 10pt;
            font-weight: 900;

            fill: #000000;
        }
    </style>
</head>

<body>
    <svg width="100%" height="100%">
    <style>
        .big {font: 10vw}
        .small { font: italic 1vw sans-serif; }
        .heavy { font: bold 1vw sans-serif; }
    </style>
    
    <text x="67%" y="6%" fill="black"> Welcome to David's publication network!</text>
    <text x="67%" y="12%" fill="black"> Network links are based on the number of </text>
    <text x="67%" y="18%" fill="black"> times the publications are co-cited in other documents.</text>
    <text x="67%" y="24%" fill="black"> Node color represents the year of documents.</text>
    <text x="67%" y="30%" class="heavy" fill="aqua" > latest</text>
    <text x="72%" y="30%"  fill="black"> -----> </text>
    <text x="77%" y="30%" fill="navy" class="heavy"> oldest</text>
    <text x="67%" y="36%" fill="black"> Thickness of links represents the number of cocitations.</text>
    <text x="67%" y="42%" class = "small" fill="black"> less cocitations</text>
    <text x="77%" y="42%"  fill="black"> -----> </text>
    <text x="83%" y="42%" fill="black" class="heavy"> more cocitations</text>
    <text x="67%" y="48%" fill="red" class="heavy"> USER GUIDE: </text>
    <text x="67%" y="54%" fill="black"> .hover over a node to see the name of document. </text>
    <text x="67%" y="60%" fill="black"> .drag node to see how dynamic changes. </text>
    <text x="67%" y="66%" fill="black"> .click on a node to see its own connections and subplots. </text>
    <text x="67%" y="72%" fill="black"> .If you are in the subplot, click on the red node to come </text>
    <text x="67%" y="78%" fill="black"> back to the original graph.</text>

</svg>

<script src="https://d3js.org/d3.v5.min.js"></script>



<script>

function testing(graph){

    var baseNodes = graph.nodes
    var baseLinks = graph.links
    

    var nodes = [...baseNodes]
    var links = [...baseLinks]
    
    
    function get_max(data, col){
        max = 0;
        for(var i = 0 ; i < data.length; i ++){
            if(data[i][col] > max){
                max = data[i][col]
            }
        }
        return max;
    }
    
    function get_min(data, col){
        min = 3000;
        for(var i = 0 ; i < data.length; i ++){
            if(data[i][col] < min){
                min = data[i][col]
            }
        }
        return min;
    }
    
    function get_color(curr_node){
        var scale_year = d3.scaleLinear()
                            .domain([-get_max(nodes, "year"), -get_min(nodes, "year")])
                            .range([0.5, 1]);
        return d3.interpolateGnBu(scale_year(-curr_node.year))

    }
    
    function wrap(description, width) {
        width = width * window.innerWidth;
        description.each(function () {
            var description = d3.select(this),
                words = description.text()
                            .split(/\s+/)
                            .reverse(),
                word,
                line = [],
                lineNumber = 0,
                lineHeight = 1.1, // ems
                x = description.attr("x"),
                y = description.attr("y"),
                dy = 0, //parseFloat(text.attr("dy")),
                tspan = description.text(null)
                            .append("tspan")
                            .attr("x", x)
                            .attr("y", y)
                            .attr("dy", dy + "em");
            while (word = words.pop()) {
                line.push(word);
                tspan.text(line.join(" "));
                if (tspan.node().getComputedTextLength() > width) {
                    line.pop();
                    tspan.text(line.join(" "));
                    line = [word];
                    tspan = description.append("tspan")
                                .attr("x", x)
                                .attr("y", y)
                                .attr("dy", ++lineNumber * lineHeight + dy + "em")
                                .text(word);
                }
            }
            word = "text"
            line.push(word);
            tspan.text(line.join(" "));
            line.pop();
            tspan.text(line.join(" "));
            line = [word]
            tspan = description.append("tspan")
                        .attr("x", x)
                        .attr("y", y)
                        .attr("dy", ++lineNumber * lineHeight + dy + "em")
                        .text(word);
        });
    }
    
    function getNeighbors(node) {
        return baseLinks.reduce(function (neighbors, link) {
            if (link.target.id === node.id) {
                neighbors.push(link.source.id)
            }else if(link.source.id === node.id) {
                neighbors.push(link.target.id)
            }
        return neighbors}, [node.id])
    }
    
    function isNeighborLink(node, link, neighbors) {
        return node.level == 2
        return link.target.id === node.id || link.source.id === node.id
    }
    
    
    function getNodeColor(node, neighbors, selectedNode) {
        if(node.id == selectedNode.id) {
            return 'red'
        }
        return get_color(node)
    }
    
    function getTextColor(node, neighbors) {
      return "black"
    }
    function getLinkColor(node, link, neighbors) {
        return isNeighborLink(node, link, neighbors) ? 'green' : '#E5E5E5'
    }
    
    
    var width = window.innerWidth * 0.9
    var height = window.innerHeight * 0.9
    var radius = 10
    
    var svg = d3.select('svg')
    svg.attr('width', width).attr('height', height)
    
    
    
    
    var linkElements,
        nodeElements,
        textElements
    
    // we use svg groups to logically group the elements together
    var linkGroup = svg.append('g').attr('class', 'links')
    var nodeGroup = svg.append('g').attr('class', 'nodes')
    var textGroup = svg.append('g').attr('class', 'texts')
    
    // we use this reference to select/deselect
    // after clicking the same element twice
    var selectedId
    
    // simulation setup with all forces
    var linkForce = d3
        .forceLink()
        .id(function (link) { return link.id })
        .strength(function (link) { return link.scaled_cocitation  })
    
    var simulation = d3.forceSimulation()
        .force('link', linkForce)
        .force('charge', d3.forceManyBody().strength(-60))
        .force('center', d3.forceCenter(width / 3, height / 2))
        .force("x", d3.forceX().strength(0.01))
        .force("y", d3.forceY().strength(0.03));
    
    var dragDrop = d3.drag().on('start', function (node) {
        node.fx = node.x
        node.fy = node.y
    }).on('drag', function (node) {
        simulation.alphaTarget(0.03).restart()
        node.fx = d3.event.x
        node.fy = d3.event.y
    }).on('end', function (node) {
        if (!d3.event.active) {
          simulation.alphaTarget(0)
        }
        node.fx = null
        node.fy = null
    })
    
    // select node is called on every click
    // we either update the data according to the selection
    // or reset the data if the same node is clicked twice
    function selectNode(selectedNode) {
        if (selectedId === selectedNode.id) {
            selectedId = undefined
            // resetData()
            // updateSimulation()
            location.reload()
            if (showingText) updateSimulation(showingText)
        } else {
            selectedId = selectedNode.id
            updateData(selectedNode)
            updateSimulation(showingText)
        }
    
        d3.select("#tooltip_id").remove(); 
        d3.select("#tooltip_description").remove(); 
        d3.select("#tooltip_nums").remove(); 
    
        var tooltip_id = nodeGroup.append("text")
                                .text("ID: " + selectedNode.id)
                                .attr("x", 0)
                                .attr("y", 100)
                                .attr("id", "tooltip_id");
        tooltip_id.attr("text-anchor", "start");
        tooltip_id.attr("dx", 0);
                
        var tooltip_description = nodeGroup.append("text")
                                .text("Description: " + selectedNode.description)
                                .attr("x", 0)
                                .attr("y", 120)
                                .attr("id", "tooltip_description")
                                .call(wrap, 0.5);
        tooltip_description.attr("text-anchor", "start");
        tooltip_description.attr("dx", 0);
    
        var tooltip_nums = nodeGroup.append("text")
                                .text("Citation: " + selectedNode.total_citation)
                                .attr("x", 0)
                                .attr("y", 140)
                                .attr("id", "tooltip_nums");
        tooltip_nums.attr("text-anchor", "start");
        tooltip_nums.attr("dx", 0);
    
        var neighbors = getNeighbors(selectedNode)
    
        // we modify the styles to highlight selected nodes
        nodeElements.attr('fill', function (node) { 
            return getNodeColor(node, neighbors,selectedNode) 
        })
        textElements.attr('fill', function (node) { return getTextColor(node, neighbors) })
        linkElements.attr('stroke', function (link) { 
            return getLinkColor(selectedNode, link, neighbors)
        })
    }
    
    // this helper simple adds all nodes and links
    // that are missing, to recreate the initial state
    function resetData() {
        var nodeIds = nodes.map(function (node) { return node.id })
    
        baseNodes.forEach(function (node) {
            if (nodeIds.indexOf(node.id) === -1) {
                nodes.push(node)
            }
        })
    
        links = baseLinks
    }
    
    // diffing and mutating the data
    function updateData(selectedNode) {
        var neighbors = getNeighbors(selectedNode)
        var newNodes = baseNodes.filter(function (node) {
            return neighbors.indexOf(node.id) > -1 || node.level === 1
        })
    
        var diff = {
            removed: nodes.filter(function (node) { return newNodes.indexOf(node) === -1 }),
            added: newNodes.filter(function (node) { return nodes.indexOf(node) === -1 })
        }
    
        diff.removed.forEach(function (node) { nodes.splice(nodes.indexOf(node), 1) })
        diff.added.forEach(function (node) { nodes.push(node) })
    
        links = baseLinks.filter(function (link) {
    
            if (Array.isArray(neighbors) 
                && neighbors.indexOf(link.source.id) > -1
                && neighbors.indexOf(link.target.id) > -1){
                return true
            }
            
            return link.target.id === selectedNode.id
                    || link.source.id === selectedNode.id
    
        })
    }
    //these functions here to swtich the text showing and hiding.
    showingText = false;
    document.getElementById("button").addEventListener("change", function() {
        var status = d3.select(this).property("value") 
        if (status == 1) {
            showingText = true
            updateSimulation(showingText);        
        }
        else {
            showingText = false
            updateSimulation(showingText);
        }
    });
    
    // here we deal with the slider listener.
    var currGravity = -30;
    var currForceX = 0.01;
    var currForceY = 0.03;
    var gravitySlider = document.getElementById("gravity");
    gravitySlider.oninput = function() {
        currGravity = this.value;
        simulation = d3.forceSimulation()
                    .force('link', linkForce)
                    .force('charge', d3.forceManyBody().strength(currGravity))
                    .force('center', d3.forceCenter(width / 3, height / 2))
                    .force("x", d3.forceX().strength(currForceX))
                    .force("y", d3.forceY().strength(currForceY));
         updateSimulation(showingText);
        
    }
    
    var forceXSlider = document.getElementById("forceX");
    forceXSlider.oninput = function() {
        currForceX = this.value / 1000;
        simulation = d3.forceSimulation()
                    .force('link', linkForce)
                    .force('charge', d3.forceManyBody().strength(currGravity))
                    .force('center', d3.forceCenter(width / 3, height / 2))
                    .force("x", d3.forceX().strength(currForceX))
                    .force("y", d3.forceY().strength(currForceY));
         updateSimulation(showingText);
        
    }
    
    var forceYSlider = document.getElementById("forceY");
    forceYSlider.oninput = function() {
        currForceY = this.value / 1000;
        simulation = d3.forceSimulation()
                    .force('link', linkForce)
                    .force('charge', d3.forceManyBody().strength(currGravity))
                    .force('center', d3.forceCenter(width / 3, height / 2))
                    .force("x", d3.forceX().strength(currForceX))
                    .force("y", d3.forceY().strength(currForceY));
         updateSimulation(showingText);
        
    }
    function updateGraph(showingText) {
        // links
        linkElements = linkGroup.selectAll('line')
            .data(links, function (link) {
                return link.target.id + link.source.id
            })
    
        linkElements.exit().remove()
    
        var scale_opacity = d3.scaleLinear()
                            .domain([get_min(links, "num_cocitation"), get_max(links, "num_cocitation")])
                            .range([0.5, 1]);
    
        var linkEnter = linkElements
            .enter().append('line')
            .attr('stroke', 'rgba(50, 50, 50, 0.2)')
            .style("stroke-width", function(link) {
                return Math.sqrt(link.num_cocitation);
            })
            .style("stroke-opacity", function(link) {
                return scale_opacity(link.num_cocitation);
        })
    
        linkElements = linkEnter.merge(linkElements)
    
        // we enter text element first.
        textElements = textGroup.selectAll('text')
        .data(nodes, function (node) { return node.id })
    
        textElements.exit().remove()
        textEnter = textElements
            .enter()
            .append('text')
            .text(function (node) { return node.id  })
            .attr('font-size', 0)
            .attr('dx', 15)
            .attr('dy', 4)
            .attr("fill-opacity", 1)
            .classed('noselect', true)
    
        if (!showingText) {
            textElements.attr("font-size", 0)
        } else {
            textElements.attr("font-size", 15)
        }
    
    
        textElements = textEnter.merge(textElements)
    
        
        // nodes
        nodeElements = nodeGroup.selectAll('circle')
            .data(nodes, function (node) { return node.id })
    
        nodeElements.exit().remove()
    
        var scale_citation = d3.scaleSqrt()
                            .domain([get_min(nodes, "total_citation"), get_max(nodes, "total_citation")])
                            .range([3, 10]);
    
        var nodeEnter = nodeElements
            .enter()
            .append('circle')
            .attr("r",  function(node) { 
                return scale_citation(node.total_citation); 
            })
            .attr('fill', function(node){
                return get_color(node);
            })
            .call(dragDrop)
            // we link the selectNode method here to update the graph on every click
            .on('click', selectNode)
      
        nodeEnter.append("title")
        .text(function(d) {return "ID :  " + d.id
                                  +"\n" +"Description :  " + d.description
                                  +"\n" +"Cited by :  " + d.total_citation; });
    
        nodeElements = nodeEnter.merge(nodeElements)
    }
    
    function updateSimulation(showingText) {
        updateGraph(showingText)
    
        simulation.nodes(nodes).on('tick', () => {
            
            textElements
            .attr('x', function (node) { return (node.x = Math.max(radius, Math.min(0.5 * width - radius, node.x))); })
            .attr('y', function (node) { return (node.y = Math.max(radius, Math.min(height - radius, node.y))); })
            
            nodeElements
              .attr('cx', function (node) { return (node.x = Math.max(radius, Math.min(0.5 * width - radius, node.x))); })
              .attr('cy', function (node) { return (node.y = Math.max(radius, Math.min(height - radius, node.y))); })
            
            linkElements
              .attr('x1', function (link) { return link.source.x })
              .attr('y1', function (link) { return link.source.y })
              .attr('x2', function (link) { return link.target.x })
              .attr('y2', function (link) { return link.target.y })
        })
    
        simulation.force('link').links(links)
        simulation.alphaMin(0.03)
    }
    
    // last but not least, we call updateSimulation
    // to trigger the initial render
    
    updateSimulation(showingText)
    
    }

    d3.json("link_node.json")
        .then(testing);

    </script>

</body>
</html>